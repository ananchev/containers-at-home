- hosts: homelab
  become: true 
  gather_facts: False
  vars:
    application: passbolt
    host_directory: "{{ docker_data_root }}/{{ application }}"
    docker_network: "{{ application }}-net"
    local_backup_folder: "{{ application_data }}/{{ application }}"
    mariadb_replication_server_id: 1 # Must be unique across Alpha and Beta MariaDB instances
    mariadb_replication_read_only: false # Keep primary DB read-write during normal operation
    dr_env_file: "{{ host_directory }}/dr-secrets.env"

  tasks:
    - name: Run only on the on the designated host
      block:
      - name: Create directories
        file:
          path: "{{ item }}"
          state: directory
          mode: '0755'
        loop:
          - "{{ host_directory }}"
          - "{{ host_directory }}/backup"
          - "{{ host_directory }}/mysql-data"
          - "{{ host_directory }}/mysql-conf"
          - "{{ host_directory }}/gpg"
          - "{{ host_directory }}/jwt"

      - name: Create the common network for passbolt
        community.docker.docker_network:
          name: "{{ docker_network }}"
          driver: bridge
          state: present

      - name: Create DR credentials environment file on Alpha host
        ansible.builtin.copy:
          content: |
            export PASSBOLT_MYSQL_ROOT_PASSWORD={{ passbolt_mysql_root_password | to_json }}
            export CLOUDFLARE_TOKEN_USERNAME={{ inadyn_cloudflare_token_username | to_json }}
            export CLOUDFLARE_API_TOKEN={{ inadyn_cloudflare_token_password | to_json }}
          dest: "{{ dr_env_file }}"
          owner: root
          group: root
          mode: "0600"

      - name: Create update-dns script for Cloudflare DNS updates after temporary failover to the recovery instance
        ansible.builtin.copy:
          content: |
            #!/usr/bin/env bash
            set -euo pipefail

            set -a
            source "{{ dr_env_file }}"
            set +a

            AUTH_HEADER="Authorization: Bearer ${CLOUDFLARE_API_TOKEN}"
            DOMAIN="passbolt.tonio.cc"
            PUBLIC_IP="$(curl -fsS ifconfig.me)"

            ZONE_ID="$(curl -fsS \
                -H "${AUTH_HEADER}" \
                "https://api.cloudflare.com/client/v4/zones?name=tonio.cc&status=active" \
                | jq -r '.result[0].id')"

            RECORD_ID="$(curl -fsS \
                -H "${AUTH_HEADER}" \
                "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?type=A&name=${DOMAIN}" \
                | jq -r '.result[0].id')"

            PAYLOAD="$(printf '{"type":"A","name":"%s","content":"%s","ttl":1,"proxied":true}' \
                "${DOMAIN}" "${PUBLIC_IP}")"

            curl -fsS -X PUT \
                "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${RECORD_ID}" \
                -H "${AUTH_HEADER}" \
                -H "Content-Type: application/json" \
                --data "${PAYLOAD}"
          dest: "{{ host_directory }}/update-dns.sh"
          owner: root
          group: root
          mode: "0700"

      - name: Create show-master-status script on Alpha host
        ansible.builtin.copy:
          content: |
            #!/usr/bin/env bash
            set -euo pipefail

            set -a
            source "{{ dr_env_file }}"
            set +a

            docker exec -i mariadb-passbolt mariadb -uroot -p"${PASSBOLT_MYSQL_ROOT_PASSWORD}" -N \
                -e "SHOW MASTER STATUS;"

            echo ""
            echo "expected output is <mysql-bin.000003	19652> but values will differ."
            echo "take a note of the <mysql-bin.xxxxx> as MASTER_LOG_FILE and yyyyy as MASTER_LOG_POS coordinates"
            echo "Then on the recovery host run:"
            echo "  sudo {{ docker_data_root }}/passbolt-recovery/set-replication-source.sh <MASTER_LOG_FILE> <MASTER_LOG_POS>"
          dest: "{{ host_directory }}/show-master-status.sh"
          owner: root
          group: root
          mode: "0700"

      - name: Deploy the maria-db container
        block:
        - name: Set a fact with maria-db container name
          set_fact:
            container_name: mariadb-passbolt

        - name: Copy the database dump to remote machine
          ansible.builtin.copy:
            src: "{{ local_backup_folder }}/db_backup.sql"
            dest: "{{ host_directory }}/backup"

        - name: Render MariaDB replication config to remote machine
          ansible.builtin.template:
            src: ../_templates/mariadb-replication.cnf.j2
            dest: "{{ host_directory }}/mysql-conf/99-replication.cnf"
            mode: '0644'

        - name: Add MariaDB files to selinux_files_to_label
          set_fact:
            selinux_files_to_label:
            - "{{ host_directory }}/backup/db_backup.sql"
            - "{{ host_directory }}/mysql-conf/99-replication.cnf"

        - name: Configure SELinux
          ansible.builtin.include_tasks:
            file: ../_templates/configure_selinux.yml

        - name: Run the maria-db container
          community.docker.docker_container:
            name: "{{ container_name }}"
            network_mode: "{{ docker_network }}"
            image: "{{ app_versions['mariadb-passbolt']['image'] }}"
            detach: true
            volumes:
              - "{{ host_directory }}/mysql-data:/var/lib/mysql:Z"
            mounts:
              - source: "{{ host_directory }}/backup/db_backup.sql"
                target: /docker-entrypoint-initdb.d/passbolt-db.sql
                type: bind
                read_only: no
              - source: "{{ host_directory }}/mysql-conf/99-replication.cnf"
                target: /etc/mysql/conf.d/99-replication.cnf
                type: bind
                read_only: yes
            restart_policy: unless-stopped
            env:
              MYSQL_ROOT_PASSWORD: "{{ passbolt_mysql_root_password }}"
              MYSQL_DATABASE: "{{ passbolt_mysql_db }}"
              MYSQL_USER: "{{ passbolt_mysql_user }}"
              MYSQL_PASSWORD: "{{ passbolt_mysql_pass }}"
            published_ports:
              - "3306:3306"

        - name: Get details of the maria-db container
          community.docker.docker_container_info:
            name: "{{ container_name }}"
          register: mysql_container_info

        - name: Wait for MariaDB to accept connections
          wait_for:
            host: "{{ mysql_container_info.container.NetworkSettings.Networks[docker_network].IPAddress }}"
            port: "3306"
            state: started
            delay: 5
            timeout: 60
            sleep: 5

        - name: Recovery instance re-setup instructions
          ansible.builtin.debug:
            msg:
              - "Beta rebuild flow after the main instance (Alpha) restore:"
              - "1) On Alpha's host, get current coordinates:"
              - "docker exec -i mariadb-passbolt mariadb -uroot -p'{{ passbolt_mysql_root_password }}' -N -e \"SHOW MASTER STATUS;\""
              - "Record the two values: first is the MASTER_LOG_FILE and the second is the MASTER_LOG_POS."
              - "2) Hard-reset the recovery (Beta) instance by removing both containers (passbolt-recovery and mariadb-passbolt-recovery) and removing their host folder so Beta starts from a fully clean state."
              - "3) Re-deploy Beta by running the passbolt-recovery playbook."
              - "4) Reconfigure replication on Beta (replace placeholders) and run on its host:"
              - "docker exec -i mariadb-passbolt-recovery mariadb -uroot -p'{{ passbolt_mysql_root_password }}' -e \""
              - "STOP SLAVE;"
              - "RESET SLAVE ALL;"
              - "CHANGE MASTER TO"
              - "  MASTER_HOST='{{ hostvars[inventory_hostname].ansible_host | default(inventory_hostname) }}',"
              - "  MASTER_PORT=3306,"
              - "  MASTER_USER='root',"
              - "  MASTER_PASSWORD='{{ passbolt_mysql_root_password }}',"
              - "  MASTER_LOG_FILE='<MASTER_LOG_FILE>',"
              - "  MASTER_LOG_POS=<MASTER_LOG_POS>,"
              - "  MASTER_SSL=0,"
              - "  MASTER_SSL_VERIFY_SERVER_CERT=0;"
              - "START SLAVE;"
              - "SHOW SLAVE STATUS\\G"
              - "\""
              - "5) Wait 15 seconds for replication to start"
              - "6) On Beta, run"
              - "   docker exec -it mariadb-passbolt-recovery mariadb -uroot -p'{{ passbolt_mysql_root_password }}' -e \"SHOW SLAVE STATUS\\G\""
              - "Confirm: Slave_IO_Running=Yes, Slave_SQL_Running=Yes, Seconds_Behind_Master=0 (or quickly converging)."

      - name: Deploy the passbolt container
        block:
        - name: Set a fact with the passbolt container name
          set_fact:
            container_name: passbolt

        - name: Wait 10s to secure maria-db container is running
          wait_for:
            host: "{{ mysql_container_info.container.NetworkSettings.Networks[docker_network].IPAddress }}"
            port: "3306"
            state: started
            delay: 10
            timeout: 60
            sleep: 5

        - name: Copy the backup archive with server gpg keys & the ssl certs to the remote machine
          ansible.builtin.copy:
            src: "{{ local_backup_folder }}/backup.tar.gz"
            dest: "/tmp"

        - name: Unzip the archive
          ansible.builtin.command: >
            tar -xzvf /tmp/backup.tar.gz -C {{ host_directory }}/backup
          become: true
        
        - name: Move the ssl certs from backup directory to the mount directory
          ansible.builtin.command: >  
            mv {{ host_directory }}/backup/backup/cert {{ host_directory }}
          become: true

        - name: Move gpg keys from backup directory to the mount directory
          ansible.builtin.command: >  
            mv {{ host_directory }}/backup/backup/gpg {{ host_directory }}
          become: true

        - name: Change gpg keys ownership to container's www-data user uid:gid
          ansible.builtin.command: >  
            chown 33:33 {{ host_directory }}/gpg/{{ item }}
          become: true
          loop:
            - serverkey.asc
            - serverkey_private.asc

        - name: Change gpg keys permissions
          ansible.builtin.command: >  
            chmod 0440 {{ host_directory }}/gpg/{{ item }}
          become: true
          loop:
            - serverkey.asc
            - serverkey_private.asc

        - name: Set selinux_files_to_label for the ssl certs and gpg keys
          set_fact:
            selinux_files_to_label:
              - "{{ host_directory }}/cert/certificate.crt"
              - "{{ host_directory }}/cert/certificate.key"
              - "{{ host_directory }}/gpg/serverkey.asc"
              - "{{ host_directory }}/gpg/serverkey_private.asc"
        
        - name: Configure SELinux
          ansible.builtin.include_tasks:
            file: ../_templates/configure_selinux.yml

        - name: Change jwt folder ownership to container's www-data user uid:gid
          ansible.builtin.command: >  
            chown 33:33 {{ host_directory }}/jwt
          become: true

        - name: Run the passbolt container
          community.docker.docker_container:
            name: "{{ container_name }}"
            network_mode: "{{ docker_network }}"
            image: "{{ app_versions['passbolt']['image'] }}"
            detach: true
            ports:
            - "8082:80"
            - "4433:443"
            volumes:
              - "{{ host_directory }}/jwt:/etc/passbolt/jwt:Z"
              - "{{ host_directory }}/gpg:/etc/passbolt/gpg:Z"
            mounts:
              - source: "{{ host_directory }}/cert/certificate.crt"
                target: /etc/ssl/certs/certificate.crt
                type: bind
                read_only: yes
              - source: "{{ host_directory }}/cert/certificate.key"
                target: /etc/ssl/certs/certificate.key
                type: bind
                read_only: yes
            restart_policy: unless-stopped
            env:
              APP_FULL_BASE_URL: "{{ passbolt_app_full_base_url }}"
              DATASOURCES_DEFAULT_HOST: "{{ mysql_container_info.container.NetworkSettings.Networks[docker_network].DNSNames[0] }}"
              DATASOURCES_DEFAULT_DATABASE: "{{ passbolt_mysql_db }}"
              DATASOURCES_DEFAULT_USERNAME: "{{ passbolt_mysql_user }}"
              DATASOURCES_DEFAULT_PASSWORD: "{{ passbolt_mysql_pass }}"
              PASSBOLT_SSL_FORCE: "true"
              PASSBOLT_SECURITY_SMTP_SETTINGS_ENDPOINTS_DISABLED: "false"
              PASSBOLT_GPG_SERVER_KEY_FINGERPRINT: "{{ passbolt_gpg_server_key_fingerprint }}"
              PASSBOLT_KEY_EMAIL: "{{ passbolt_key_email }}"
            command: >
              /usr/bin/wait-for.sh -t 0 {{ mysql_container_info.container.NetworkSettings.Networks[docker_network].DNSNames[0] }}:3306 -- /docker-entrypoint.sh

        # - name: Get the www-data uid and gid in the passbolt container
        #   command: docker exec passbolt sh -c "id www-data"
        #   register: id_output

        # - name: Parse UID and GID from the output
        #   set_fact:
        #     uid: "{{ id_output.stdout | regex_search('uid=([0-9]+)', '\\1') | int }}"
        #     gid: "{{ id_output.stdout | regex_search('gid=([0-9]+)', '\\1') | int }}"

      when: inventory_hostname in application_hosts['passbolt']